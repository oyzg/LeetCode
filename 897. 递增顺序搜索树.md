# [897. 递增顺序搜索树](https://leetcode-cn.com/problems/increasing-order-search-tree/)

给你一棵二叉搜索树，请你 **按中序遍历** 将其重新排列为一棵递增顺序搜索树，使树中最左边的节点成为树的根节点，并且每个节点没有左子节点，只有一个右子节点。



**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/11/17/ex1.jpg)

```
输入：root = [5,3,6,2,4,null,8,1,null,null,null,7,9]
输出：[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]
```

​	

**提示：**

- 树中节点数的取值范围是 `[1, 100]`
- `0 <= Node.val <= 1000`



## 题解

排列成一个递增顺序搜索树 即 将root移至root左子树的最右边的叶子结点的right上，并且root的right等于右子树的最左叶子节点

例：
root = [5,3,6,2,4,null,8,1,null,null,null,7,9]

![897-1.png](https://pic.leetcode-cn.com/1619314404-vyTMCd-897-1.png)

1.将root移至root左子树的最右边的叶子结点的right上

![897-2.png](https://pic.leetcode-cn.com/1619314449-UMRpAT-897-2.png)

2.root的right等于右子树的最左叶子节点

![897-3.png](https://pic.leetcode-cn.com/1619314477-ONnjZH-897-3.png)


3.然后递归处理root原来的左节点和右节点即可

第一次画图，画的不好，请见谅！



```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode increasingBST(TreeNode root) {
        if(root == null) return null;
		TreeNode cur = root;
		TreeNode left = root.left;
		if(root.left != null) {
			cur =cur.left;
			while(cur.right != null) {
				cur = cur.right;
			}
			root.left = null;
			cur.right = root;
		}
		
		if(root.right != null) {
			root.right = increasingBST(root.right);
		}
		return left == null ? root : increasingBST(left);
    }
}
```



作者：oyzg
链接：https://leetcode-cn.com/problems/increasing-order-search-tree/solution/tu-jie-897-di-zeng-shun-xu-sou-suo-shu-d-tn83/