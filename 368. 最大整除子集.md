# [368. 最大整除子集](https://leetcode-cn.com/problems/largest-divisible-subset/)

给你一个由 无重复 正整数组成的集合 nums ，请你找出并返回其中最大的整除子集 answer ，子集中每一元素对

(answer[i], answer[j]) 都应当满足：

- answer[i] % answer[j] == 0 ，或
- answer[j] % answer[i] == 0

如果存在多个有效解子集，返回其中任何一个均可。



```
输入：nums = [1,2,3]
输出：[1,2]
解释：[1,3] 也会被视为正确答案。
```



**提示：**

- `1 <= nums.length <= 1000`
- `1 <= nums[i] <= 2 * 109`
- `nums` 中的所有整数 **互不相同**



## 题解

方法：**动态规划**

1. list.get(i)代表以nums[i]为结尾的集合的最大整除子集
2. 推导公式：
   - 遍历i之前的所有结果
   - 如果nums[i]%nums[j] == 0:
   - list.get(i) = list.get(j)的复制
   - 遍历完后，在当前子集后加上nums[i]
3. 初始化：list.add(new ArrayList<>());
   - list.get(0).add(nums[0]);



注意：

- 要先将数组排序
- cur = new ArrayList<>(list.get(j));不要写成 cur = list.get(i);

有不对的地方请指教!



```java
class Solution {
    public List<Integer> largestDivisibleSubset(int[] nums) {
        int n = nums.length;
		//排序
		Arrays.sort(nums);
		//初始化
		ArrayList<ArrayList<Integer>> list = new ArrayList<ArrayList<Integer>>();
		ArrayList<Integer> first = new ArrayList<Integer>();
		first.add(nums[0]);
		list.add(first);
		for(int i = 1; i < nums.length; i++) {
			ArrayList<Integer> cur = new ArrayList<Integer>();
			for(int j = i-1; j >= 0; j--) {
				if(nums[i] % nums[j] == 0) {
					if(list.get(j).size() > cur.size()) {
						cur = new ArrayList<>(list.get(j));
					}
				}
			}
			cur.add(nums[i]);
            list.add(cur);
		}
		//找到最长的子集
		int max = 0;
		int index = 0;
		for(int i = 0; i < n; i++) {
			if(list.get(i).size() > max) {
				index = i;
				max = list.get(i).size();
			}
		}
		return list.get(index);
    }
}
```

作者：oyzg
链接：https://leetcode-cn.com/problems/largest-divisible-subset/solution/368zui-da-zheng-chu-zi-ji-dong-tai-gui-h-xctj/

